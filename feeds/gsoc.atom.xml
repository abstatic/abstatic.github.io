<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Mantis</title><link href="http://abstatic.github.io/" rel="alternate"></link><link href="http://abstatic.github.io/feeds/gsoc.atom.xml" rel="self"></link><id>http://abstatic.github.io/</id><updated>2016-06-21T00:00:00+05:30</updated><entry><title>New Chromosome viewer for SegAnn</title><link href="http://abstatic.github.io/new-chromosome-viewer.html" rel="alternate"></link><updated>2016-06-21T00:00:00+05:30</updated><author><name>Abhishek Shrivastava &lt;x.abhishek.flyhigh@gmail.com&gt;</name></author><id>tag:abstatic.github.io,2016-06-21:new-chromosome-viewer.html</id><summary type="html">&lt;h2&gt;Creating a new chromosome viewer for SegAnnDB : Design &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Implementation Details&amp;nbsp;-&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Screenshot" src="http://i.imgur.com/NDWmt6u.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;* The upper part is the overview of the chrome and is the standard zoom file.
* The lower part is the zoomed in chromosome, and its zoom levels can be modified. Current zoom levels are – ipad, chrome\_ubuntu, chrome\_windows (no changes 
here)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1.Changes in storing&amp;nbsp;images-&lt;/h3&gt;
&lt;p&gt;I have modified the file keeping scheme of segann. Now each generated goes into the chromosome folder as&amp;nbsp;well.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  secret
  +
  +---profile (e.g. ES0004)
  + |
  + |--------1
  + |   *-&amp;gt; ES0004_chr1_standard.png
  + |   *-&amp;gt; ES0004_chr1_profiles.png
  + |   *-&amp;gt; ES0004_chr1_chrome_ubuntu_1.png
  + |
  + |--------2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So all the images now go into their corresponding chromosome number folder. (its X for the last&amp;nbsp;chr)&lt;/p&gt;
&lt;p&gt;Changes made in other parts of the application to accomodate the new file keeping&amp;nbsp;scheme&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;File - &lt;code&gt;__init.py__&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The route &lt;code&gt;secret&lt;/code&gt; has been modified, on line number&amp;nbsp;30&lt;/p&gt;
&lt;p&gt;Original  - 
  &lt;code&gt;config.add_route("secret","/secret/{name:%s}{suffix}"%name_regex)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Modified-
  &lt;code&gt;config.add_route("secret","/secret/{profile_name}/{chr_num}/{name:%s}{suffix}"%name_regex)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;File- &lt;code&gt;views.py&lt;/code&gt; , &lt;code&gt;route="secret"&lt;/code&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;The new code for this route is as follows – (old code is commented&amp;nbsp;out)  &lt;/p&gt;
&lt;p&gt;&lt;pre&gt;
  @view_config(route_name="secret")
  def secret_new(request):
      # fn = db.secret_file("%(name)s%(suffix)s" % request.matchdict)
      # return FileResponse(fn, request=request)
      profileName = request.matchdict["profile_name"]
      chr_num = request.matchdict["chr_num"]
      file_name = "%(name)s%(suffix)s" % request.matchdict
      fn = db.secret_file(file_name, chr_num)
      print fn
      return FileResponse(fn, request=request)
  &lt;/pre&gt;&lt;/p&gt;
&lt;h3&gt;2.Splitting of&amp;nbsp;Images-&lt;/h3&gt;
&lt;p&gt;As discussed before, I have added the code to split all the large size images. I am using “&lt;span class="caps"&gt;PILLOW&lt;/span&gt;” module for doing this. We are alreading using this in
  &lt;code&gt;scatterplot.py&lt;/code&gt; file. &lt;/p&gt;
&lt;p&gt;Splitting criteria – I have changed the default width to 1250px from 1500px. Because 1250 evenly divides all the other zoom levels (ipad, windows,&amp;nbsp;ubuntu)&lt;/p&gt;
&lt;p&gt;Code&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;The code for splitting images is in the file &lt;code&gt;db.py&lt;/code&gt;. I have done modifications in two places. I have created a separete function to split the images, the 
  method is called &lt;code&gt;split_image(...)&lt;/code&gt; and this method is called from the &lt;code&gt;process(...)&lt;/code&gt; method. Process method is called to create the scatterplots, calculate 
  the segmentation and breakpoints data and store it into &lt;span class="caps"&gt;BDB&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;Modifications in &lt;code&gt;process(..)&lt;/code&gt; method&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;
  ...
  ...
      meta["plots"][name] = {
          "logratio_min": lr_min,
          "logratio_max": lr_max,
          "height_px": HEIGHT_PX,
          "width_px": width,
          "width_bases": bases[ch],
          "file": scatterplot_file(pinfo["name"], ch, name,
                                   lr_min, lr_max,
                                   width, bases),
          }
      print "file created: ", meta["plots"][name]["file"]
      print "---------------"
      if meta["plots"][name]["width_px"] &amp;gt; DEFAULT_WIDTH :
          split_image(meta["plots"][name]["file"], ch, pinfo["name"], name, width)
  # print "meta- ",meta
  # print "\n\n\n\n----------\n\n\n\n\n"
  ...
  ...
  &lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;spilt_image(...)&lt;/code&gt; method works as follows&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;
  def split_image(file_name, chr_num, profile_name, suffix, width):
      """
      Parameters-
      file_name - the file name
      chr_num - the chromosome number
      profile_name - the profile id
      suffix - the zoom level
      width - the width_px of the image
      """
      file_location = SECRET_DIR + "/" + profile_name + "/" + chr_num + "/" + file_name
      save_path = SECRET_DIR + "/" + profile_name + "/" +&amp;nbsp;chr_num&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  # now open the file
  im = Image.open(file_location)

  i = DEFAULT_WIDTH
  j = 1

  while i &amp;lt;= width:
      print i
      box = (i - 1250, 0, i, 200)
      img = im.crop(box)
      fn = &amp;quot;%s_chr%s_%s_%d.png&amp;quot; % (profile_name, chr_num, suffix, j)
      final_path = save_path + &amp;quot;/&amp;quot; + fn
      img.save(final_path)
      j += 1
      i += 1250
&lt;/pre&gt;&lt;/div&gt;


&lt;/pre&gt;

&lt;p&gt;The above method splits a image into smaller images. Each splitted image has the size of 1250 pixels.The images are named similarly to their parents only the 
  index is added to the end to indicate their&amp;nbsp;sequence. &lt;/p&gt;
&lt;h3&gt;3.New chromosome viewer&amp;nbsp;-&lt;/h3&gt;
&lt;p&gt;I am implementing the new chromosome viewer for segann with help of&amp;nbsp;offsetting.&lt;/p&gt;
&lt;p&gt;As you can see in the picture, we are dividing a very large png image into
several small images of 1250px. All of these images are unique and are
sequenced using the index, which is attached at the end of file&amp;nbsp;name.&lt;/p&gt;
&lt;p&gt;Now we can render the same image of 1250 pixels everytime, but the user will
have the choice, that which part of the chromosome he wants to&amp;nbsp;annotate.&lt;/p&gt;
&lt;p&gt;Each image that is rendered can be&amp;nbsp;annotated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;D3JS&lt;/span&gt; Linear Scaling&lt;/strong&gt;
In our &lt;span class="caps"&gt;JS&lt;/span&gt; code &lt;code&gt;chromDisplay.js&lt;/code&gt; we are making use of the &lt;a href="https://github.com/d3/d3/wiki/Quantitative-Scales"&gt;linear
scaling&lt;/a&gt;. We are using
linear scales to map the base pairs to the&amp;nbsp;pixels&lt;/p&gt;
&lt;p&gt;To explain in a more general way, linear scale is&amp;nbsp;- &lt;/p&gt;
&lt;p&gt;&lt;img alt="Linear Scaling" src="https://s3.amazonaws.com/dashingd3js/images/d3.js_scales_scale_domain_down_to_range_300x300.png" /&gt;&lt;/p&gt;
&lt;p&gt;In SegAnnDB we have the domain as the number of base pairs and the range is
the width of the image, so that is fixed at 1250&amp;nbsp;pixels.&lt;/p&gt;
&lt;h2&gt;Using offsets to display various&amp;nbsp;sections**&lt;/h2&gt;
&lt;p&gt;&lt;img alt="handmade" src="http://i.imgur.com/0SD5gwz.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Motivation -&lt;/strong&gt; Using the offset based approach, it is zoom level agnostic,
meaning with this approach we can create and view images of any zoom level&amp;nbsp;efficiently.&lt;/p&gt;
&lt;p&gt;Currently how the annotation works in SegAnn is&amp;nbsp;-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;User drags the mouse on profile to do different type of annotation such as
   breakpoint, and copy number. Its done in the shape of a&amp;nbsp;rectangle.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The event is detected by &lt;code&gt;chromDisplay.js&lt;/code&gt; , and the x-coordinates of the
   rectangular region are converted to base pair (min, max) with help of
   invert function of linear scaling which allows a mapping from range to&amp;nbsp;domain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;After getting the min and mix basepairs, a simple http request is sent out
   to the server, which stores the annotation in&amp;nbsp;database.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, if we want to split out the large images into different images, and still
be able to&amp;nbsp;annotate. &lt;/p&gt;
&lt;p&gt;After doing a lot of brainstorming, I thought of just addding an offset value 
to the x-coordinates, and then invert the values to get the correct width of 
base&amp;nbsp;pairs.&lt;/p&gt;
&lt;p&gt;So, how this will work is, that in every occurence of the x-coordinates, or
inversion of coordinates, I am adding an offset value which will correspond to
the right pixel on the original image. That way we can annotate different
profiles with considerably high zoom&amp;nbsp;levels.&lt;/p&gt;
&lt;p&gt;For example, while we are sending out the request to save an annotation &lt;br /&gt;
The function saveAnnotation would get modified as -
&lt;pre&gt;
    var saveAnnotation = function(){
      var buttons = svg.selectAll("."+button_class);
      buttons.remove();
      var rect = svg.select("#"+trackType+"NEW");
      var w = parseInt(rect.attr("width"));
      // add the offset value here
      var min_px = parseInt(rect.attr("x")) + offset_px;
      var min = parseInt(x.invert(min_px));
      var max = parseInt(x.invert(min_px+w));
      var waiting = svg.append("text")
      ...
      ...
      var url = "/add_region/"+profile_id+"/"+chromosome+"/"+
    trackType+"/"+ann+"/"+min+"/"+max+"/";
      d3.json(url,function(response){
    if(response){
      ...
      ...
      ...
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;So just by adding the correct offset value we inverse map the correct
x coordinates of the svg to the correct base pairs in the&amp;nbsp;domain.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New&amp;nbsp;Route&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For developing the new viewer, I have created a new route in &lt;code&gt;views.py&lt;/code&gt;
I have commented out the default route of &lt;code&gt;chrom&lt;/code&gt; and created a new route for
&lt;code&gt;chrom&lt;/code&gt; along with a new template &lt;code&gt;new.pt&lt;/code&gt; to support&amp;nbsp;this&lt;/p&gt;
&lt;p&gt;Route - 
&lt;pre&gt;
@view_config(route_name='chrom', renderer='templates/new.pt')
@add_userid
@check_userprofiles
def hello(request):
    w = request.GET.get("width", "standard")
    i = request.GET.get("index", "1")
    md = request.matchdict
    out = prof_info(md["name"], md["chr"].split(','), w)
    out["name"] = md["name"]
    out["width"] = w
    out["others"] = [z for z in CHROM_ZOOMS if z != w]
    out["chr"] =&amp;nbsp;md["chr"]&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# in case of standard width we want to send the correct suffixes
if w == &amp;quot;standard&amp;quot;:
    out[&amp;quot;index&amp;quot;] = 0
    out[&amp;quot;index_next&amp;quot;] = &amp;quot;&amp;quot;
    out[&amp;quot;index_prev&amp;quot;] = &amp;quot;&amp;quot;
    out[&amp;quot;index_suffix&amp;quot;] = &amp;quot;&amp;quot;
else:
    out[&amp;quot;index&amp;quot;] = i
    out[&amp;quot;index_suffix&amp;quot;] = &amp;quot;_&amp;quot; + i

    if int(i) == 1:
        out[&amp;quot;index_next&amp;quot;] = str(int(i)+1)
        out[&amp;quot;index_prev&amp;quot;] = &amp;quot;1&amp;quot;
    else:
        out[&amp;quot;index_next&amp;quot;] = str(int(i)+1)
        out[&amp;quot;index_prev&amp;quot;] = str(int(i)-1)
return out
&lt;/pre&gt;&lt;/div&gt;


&lt;/pre&gt;

&lt;h4&gt;Code Explanation&amp;nbsp;-&lt;/h4&gt;
&lt;p&gt;Lets talk about, the new parameters, that we are sending to the&amp;nbsp;template-&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We are also taking a new &lt;span class="caps"&gt;GET&lt;/span&gt; request parameter, which is the index of image,
  if unsupplied it is set to&amp;nbsp;1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We are now sending out the index, index_next, index_prev parameters to the
  template, these contain the index values corresponding to current, next and
  previous indices of the image section that we are viewing right&amp;nbsp;now&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We are also sending out index_suffix, it is used to create the filename
  later on in the template and js&amp;nbsp;code.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Changes in the javascript&amp;nbsp;code&lt;/h2&gt;
&lt;p&gt;We are also doing some changes in &lt;span class="caps"&gt;JS&lt;/span&gt; code in the template&amp;nbsp;-&lt;/p&gt;
&lt;pre&gt;
var data = ${plot};
data[0][0]["width_px"] = 1250;
data[0][0]["zoom"] = "${width}";
data[0][0]["offset_px"] = (${index} - 1) * 1250;
data[0][0]["index"] = ${index}
data[0][0]["index_suffix"] = "${index_suffix}";
var profile = new profilePlot(data);
&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s all for now. The next post will cover how the final thing was
implemented along with any changes suggested by&amp;nbsp;Toby.&lt;/p&gt;</summary><category term="Gsoc"></category><category term="computational genomics"></category><category term="google summer of code"></category><category term="chromosome viewer"></category></entry><entry><title>Selenium For Testing SegAnnDB</title><link href="http://abstatic.github.io/selenium-for-testing.html" rel="alternate"></link><updated>2016-06-12T09:20:00+05:30</updated><author><name>Abhishek Shrivastava &lt;x.abhishek.flyhigh@gmail.com&gt;</name></author><id>tag:abstatic.github.io,2016-06-12:selenium-for-testing.html</id><summary type="html">&lt;h3&gt;Selenium&lt;/h3&gt;
&lt;p&gt;Selenium is a browser based testing framework which is very widely used for doing testing for various web centric apps. Selenium has bindings available for almost all the languages. Selenium is used exclusively for automating browser behaviour. In more simpler words, selenium can be described as an &lt;span class="caps"&gt;API&lt;/span&gt; for the browser. Selenium is also used in web&amp;nbsp;scraping. &lt;/p&gt;
&lt;p&gt;For python, selenium can be installed by one single command - &lt;code&gt;pip install selenium&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Browser based&amp;nbsp;testing&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Browser based testing is automating browsers for running regression and functional tests, which further test the functionality of the web application. The aim is to reduce the number of regressions which might be introduced in further development of the&amp;nbsp;application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python unit&amp;nbsp;testing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python unittest is a module which is used for writing tests in python. It provides various methods for running and setting up of&amp;nbsp;tests.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each test case method should be prefixed with the name&amp;nbsp;&amp;#8220;test_&amp;#8221;&lt;/li&gt;
&lt;li&gt;For defining the test sequence of methods, the format is - &amp;#8220;test010_&amp;#8221; , &amp;#8220;test020_&amp;#8221;&amp;nbsp;etc.&lt;/li&gt;
&lt;li&gt;There should be a &lt;code&gt;setUp&lt;/code&gt; method in the file. This method is called before running up of each test&amp;nbsp;case.&lt;/li&gt;
&lt;li&gt;Method &lt;code&gt;tearDown&lt;/code&gt; is called every time a test case method finishes&amp;nbsp;executing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Directory&amp;nbsp;Structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;All the data related to the tests goes under &lt;code&gt;SegAnnDB/tests/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Test&amp;nbsp;Profile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For doing the testing I am using a profile named &lt;span class="caps"&gt;ES0004&lt;/span&gt;. The script
automatically checks for the existence of the test profile. In case, it does
not exist it downloads it from my github repo and then the test suite
execution begins. It expects that the test profile is inside &lt;code&gt;SegAnnDB/tests/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/abstatic/SegAnnDB-tests/master/test_profile.bedGraph.gz"&gt;Test&amp;nbsp;Profile&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;The Test Cases&amp;nbsp;-&lt;/h2&gt;
&lt;p&gt;After some initial discussions, me and Toby (my mentor) decided that it would be good if I wrote test cases for checking the current functionality of application. The test cases are&amp;nbsp;-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Test whether the application is starting properly or&amp;nbsp;not&lt;/p&gt;
&lt;p&gt;Implementing this test case was trivial. We are just checking for the right value in the page title after succssfully loading the page.
  &lt;script src="https://gist.github.com/abstatic/08429f989ce571fbc1e954aae3f3f1a8.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Login the&amp;nbsp;user&lt;/p&gt;
&lt;p&gt;By far this was the trickiest part. The normal login flow in SegAnnDB is as follows&amp;nbsp;- &lt;/p&gt;
&lt;p&gt;a) Click on the signin button&lt;br /&gt;
  b) A new pop up opens up for mozilla persona&lt;br /&gt;
  c) Enter the mail id&lt;br /&gt;
  d) The pop is redirected to appropriate oauth based server of your email provider for asking permissions.&lt;br /&gt;
  e) Enter your password andd authorize&lt;br /&gt;
  f) Redirects back to mozilla persona&lt;br /&gt;
  g) Pop up closes and the user is successfully logged&amp;nbsp;in  &lt;/p&gt;
&lt;p&gt;Automating this many steps and handling so many steps was complicated. I was sure that other people must have tried to automate mozilla persona based logins.
  I came across &lt;strong&gt;&lt;a href="https://mockmyid.com"&gt;mockmyid&lt;/a&gt;&lt;/strong&gt; which is very useful for testing mozilla persona based applications for mock&amp;nbsp;users.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://mockmyid.com"&gt;mockmyid&lt;/a&gt;&lt;/strong&gt; provides mock user ids which can be used for logging in via mozilla persona. When using mockmyid the login flow is as follows&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;a) Click on signin button&lt;br /&gt;
  b) Persona popup opens&lt;br /&gt;
  c) Enter mockmyid based email&lt;br /&gt;
  d) Click on login&lt;br /&gt;
  e) Pop closes and the user is logged&amp;nbsp;in.  &lt;/p&gt;
&lt;p&gt;Assertion for a successfull login works by checking for the presence of Sign Out&amp;nbsp;field.&lt;/p&gt;
&lt;p&gt;Login is something which is used by every other test case, so I decided to make a method which can automatically log the user&amp;nbsp;in.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The login function&lt;/strong&gt;
  &lt;script src="https://gist.github.com/abstatic/f59103256e6f04c8cef37508efbd82d0.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Upload a&amp;nbsp;profile  &lt;/p&gt;
&lt;p&gt;Uploading a profile is also straightforward. The steps followed by webdriver are&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;a) Login the user &lt;br /&gt;
  b) Go to profile upload page&lt;br /&gt;
  c) Put in the path of test file&lt;br /&gt;
  d) Click on submit button&lt;br /&gt;
  e) Assert for existence of element with&amp;nbsp;id=success  &lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/abstatic/ac3cab3c9164c42a0984755bd2d0ad09.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Annotate a&amp;nbsp;chromosome&lt;/p&gt;
&lt;p&gt;This test case works very differently when compared to other test cases. It uses selenium only for logging in the user. The annotation part is done by using
  urllib2 module and sending out the get requests to the web server. The assertion works by checking for the 200 status code on the response of the request&amp;nbsp;sent.&lt;/p&gt;
&lt;p&gt;But there is one more thing with this test. It needs to sleep for a while. This is because, it will get called directly after the profile is uploaded. 
  Now, SegAnn needs some time to process a profile before it can be annotated. So the test for annotating chromosome waits for about a minute before doing&amp;nbsp;anything.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete a&amp;nbsp;profile.&lt;/p&gt;
&lt;p&gt;Deleting of a profile is simple as well. The steps followed are&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;a) Login the user&lt;br /&gt;
  b) Send a delete request to the server&lt;br /&gt;
  c) Assert for word &amp;#8220;deleted&amp;#8221; on the source code of the&amp;nbsp;response.  &lt;/p&gt;
&lt;p&gt;Now, as we will go on adding more features into SegAnn I plan to add tests for each of&amp;nbsp;them.  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All the code related to above tests can be found at
&lt;a href="https://github.com/abstatic/SegAnnDB/blob/master/tests/tests.py"&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Waits in&amp;nbsp;Selenium&lt;/h3&gt;
&lt;p&gt;Generally selenium is kindof procedural and does not handle latency very well. But with webapps, its sure that there will be some delays and waits while the page&amp;nbsp;loads. &lt;/p&gt;
&lt;p&gt;To handle these kinds of scenarios we need to put in waits in selenium while checking for existence of various elements. So, basicallly what I&amp;#8217;m doing is I poll the browser continuously for a max time limit, and check whether a certain element exists or&amp;nbsp;not&lt;/p&gt;
&lt;p&gt;There are two major types of waits available in&amp;nbsp;selenium- &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Implicit Waits - An implicit wait is to tell web driver to poll the &lt;span class="caps"&gt;DOM&lt;/span&gt;
    for a certain amount of time when trying to find and element or elements
    if they are not immediately&amp;nbsp;available. &lt;/p&gt;
&lt;p&gt;Example code - 
&lt;pre&gt;
from selenium import web driver
driver = webdriver.Firefox()
driver.implicitly_wait(30)
driver.get("https://www.google.co.in/")
driver.find_element_by_id(“lst-ib”)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;In above example the implicit wait value is given as 30sec i.e., if web
driver is able to find the element with in the given span 30sec, it
returns true else, it will raise an&amp;nbsp;exception.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explicit Waits- An explicit wait is code we define to wait for a certain
    condition to occur before proceeding further in the code. &lt;code&gt;time.sleep()&lt;/code&gt;
    is one such&amp;nbsp;example. &lt;/p&gt;
&lt;p&gt;I have extensively used explicit waits in the test suite to poll for
a certain element and proceed only if it was found. Most commonly it is
used in conjuntion with &lt;span class="caps"&gt;EC&lt;/span&gt; (Expected&amp;nbsp;Condition)&lt;/p&gt;
&lt;p&gt;Example code-
&lt;pre&gt;
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
driver = webdriver.Firefox()
driver.get("https://www.google.co.in/")
try:
   WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID,"element")))
except:
   pass
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Above code waits until 10 seconds before throwing a &lt;code&gt;TimeoutException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I have defined the default waiting time before throwing a timeout error as
60&amp;nbsp;seconds. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Time Required&lt;/strong&gt; - It mostly depends on internet and processor speed. Generally the test
suite takes about 3-5 minutes in executing all the&amp;nbsp;tests.s &lt;/p&gt;</summary><category term="Gsoc"></category><category term="computational genomics"></category><category term="google summer of code"></category><category term="selenium"></category><category term="unit testing"></category><category term="python"></category></entry><entry><title>Getting Selected In GSoC</title><link href="http://abstatic.github.io/getting-selected-gsoc.html" rel="alternate"></link><updated>2016-05-03T09:20:00+05:30</updated><author><name>Abhishek Shrivastava &lt;x.abhishek.flyhigh@gmail.com&gt;</name></author><id>tag:abstatic.github.io,2016-05-03:getting-selected-gsoc.html</id><summary type="html">&lt;h3&gt;D-Day&lt;/h3&gt;
&lt;p&gt;For me this was 23rd April 00:30 &lt;span class="caps"&gt;AM&lt;/span&gt;. After a month I had been &amp;#8216;not very patiently&amp;#8217; waiting for my GSoC result. I had high expectations. I wanted to get selected so bad. I was really nervous whole day, and to cope with it I was playing Dota2 with my friends. Then one of my friends called me up and asked me to check the results. Trembling I visited the GSoC dashboard&amp;#8230;&lt;br /&gt;
and &lt;span class="caps"&gt;VOILA&lt;/span&gt; I was selected ! I had made it. Finally, and that too on my first attempt. It is the happiest moment of my life till now. 
I am the first student ever from my college to get selected in Google Summer of Code. I only have one person to thank for my selection in GSoC, who motivated me through&amp;nbsp;everything.&lt;/p&gt;
&lt;h3&gt;Back to the&amp;nbsp;project&lt;/h3&gt;
&lt;p&gt;As mentioned in the previous post, I will be working on a computational genomics project under Canadian Centre of Computational&amp;nbsp;Genomics.&lt;/p&gt;
&lt;p&gt;My project is titled &lt;a href="https://summerofcode.withgoogle.com/projects/#6611818353000448"&gt;&amp;#8220;Improving SegAnnDB&amp;nbsp;Webapp&amp;#8221;&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;What is SegAnnDB&amp;nbsp;?&lt;/h3&gt;
&lt;p&gt;SegAnnDB is Segmentation Annotation Database. It is a webapp which is used for identifying gain, loss, amplification in a &lt;span class="caps"&gt;DNA&lt;/span&gt; segment. It is used in copy number analysis. &lt;a href="http://bioviz.rocq.inria.fr/"&gt;Here&lt;/a&gt; is a working instance of&amp;nbsp;SegAnnDB.&lt;/p&gt;
&lt;h3&gt;Copy number&amp;nbsp;variations&lt;/h3&gt;
&lt;p&gt;As per wikipedia&amp;nbsp;- &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Copy-number variations (CNVs) are a form of structural variation that manifest as deletions or duplications in the genome. For example, the chromosome that normally has sections in order as A-B-C-D might instead have sections A-B-C-C-D (a duplication of &amp;#8220;C&amp;#8221;) or A-B-D (a deletion of &amp;#8220;C&amp;#8221;). Cells with CNVs have abnormal or, for certain genes, normal variations in their copy&amp;nbsp;number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="CNV Image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Gene-duplication.png/170px-Gene-duplication.png" title="CNV Image" /&gt;&lt;/p&gt;
&lt;p&gt;Study of copy number variation is closely related to tumors. Although copy number variations are common in humans, but many studies have found that copy number variations in genes are related to diseases like tumors, cancers, alzheimers. Progress made in field of &lt;span class="caps"&gt;CNV&lt;/span&gt; will help greatly in demystifying the causes and cures behind these&amp;nbsp;diseases.&lt;/p&gt;
&lt;p&gt;SegAnnDB focuses on helping researchers analyse th copy number alterations in a&amp;nbsp;chromosome.&lt;/p&gt;
&lt;h3&gt;Project Aim&amp;nbsp;-&lt;/h3&gt;
&lt;p&gt;There is already a working version of SegAnnDB in which we can do basic but very accurate genomic segmentation. It visualizes by plotting the log ratio against chromosome length. It is one of the most accurate systems for&amp;nbsp;annotations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Add appropriate unit tests and a regression testing suite &lt;/strong&gt; using selenium testing&amp;nbsp;framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Render plots based on chromosome region &lt;/strong&gt; the user wants to&amp;nbsp;see/annotate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Permission System&lt;/strong&gt;, whereby a user can grant permissions like &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; to other&amp;nbsp;users.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Social Annotations&lt;/strong&gt; - One user will be able to share his/her annotations with other&amp;nbsp;users.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Faster Deletion of Profiles&lt;/strong&gt; - Aims to optimize the deletion algorithm from O(&lt;span class="caps"&gt;ND&lt;/span&gt;) to&amp;nbsp;O(1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. Safe Deletion of Log Files&lt;/strong&gt; - Have a cron job which will periodically delete all the unused log&amp;nbsp;files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. Docker container&lt;/strong&gt; - Package SegAnnDB as a docker&amp;nbsp;container.&lt;/p&gt;
&lt;h3&gt;Time&amp;nbsp;line-&lt;/h3&gt;
&lt;p&gt;The project timeline is as follows&amp;nbsp;-&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Project Milestones and&amp;nbsp;Deliverables&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;Community Bonding Period (April 22-May 22)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Become more familiar with the codebase and how it works.
        Realize how and what the test cases should be about. Also, find out that what would be the most efficient way of coding the other parts as well.
        Towards the last week, start coding the unit tests using Selenium test
        framework.
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;May 23 - May 30 (1 Week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Using Selenium Web Driver Framework, start writing code for the regression testing suite. I will decide what tests need to be written in my community bonding period.
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;May 31 - June 13 (2 Weeks)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Work on replacing large pngs, with functionality to view subregions of chromosome.
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;June 14 - June 20 (1 Week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Permission System - Implement a permission system so that users can grant read/write permissions on profiles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;Midterm Evaluations&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Submit midterm evaluation by June 22. Then continue coding.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;June 22 - June 28 (1 week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Wrap up the remaining work on permission system&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;June 29 - July 12 (2 Weeks)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Work on Social Annotations. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;July 13 - July 26 (2 Week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Faster deletion of profiles. Optimize O(&lt;span class="caps"&gt;ND&lt;/span&gt;) to O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;July 27 - August 2(1 Week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Cron Job for safe deletion of log files of BerkeleyDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;August 3 - August 9 (1 Week)&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Create Docker Image. Package SegAnnDB as a standalone docker container and upload it to dockerhub.
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;strong&gt;Remaining days&lt;/strong&gt;&lt;/td&gt;
    &lt;td&gt;Reserved as a buffer period in case something takes longer than expected or unforeseen difficulties arise. If everything runs as per the timeline then this period will be used for more code cleanup, better testing and more documentation.
    &lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

&lt;h3&gt;Technologies and Frameworks Involved&amp;nbsp;-&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Languages&lt;/strong&gt; - Python, Javascript and Berkeley &lt;span class="caps"&gt;DB&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1. Pyramid framework - &lt;/strong&gt; As SegAnnDB is a webapp. So it is built using pyramid web application&amp;nbsp;framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Selenium Unit testing - &lt;/strong&gt; For creating unit testing framework, I will use python bindings of&amp;nbsp;selenium.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. D3 &lt;span class="caps"&gt;JS&lt;/span&gt; - &lt;/strong&gt; It is a &lt;span class="caps"&gt;JS&lt;/span&gt; library for visualizing data on the client side. It handles showing annotations and also, uploading them to&amp;nbsp;ssrver.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. PruneDP and Segannot - &lt;/strong&gt; SegAnnDB uses machine learning for getting accurate breakpoints beforehand, then the user can verify and add his&amp;nbsp;own.&lt;/p&gt;
&lt;p&gt;I hope I have well explained the project. If you still have doubts please feel free to comment here or email me at&amp;nbsp;x.abhishek.flyhigh@gmail.com&lt;/p&gt;</summary><category term="Gsoc"></category><category term="computational genomics"></category><category term="google summer of code"></category></entry><entry><title>Starting Out In GSoC</title><link href="http://abstatic.github.io/preparing-for-gsoc.html" rel="alternate"></link><updated>2016-05-02T10:20:00+05:30</updated><author><name>Abhishek Shrivastava &lt;x.abhishek.flyhigh@gmail.com&gt;</name></author><id>tag:abstatic.github.io,2016-05-02:preparing-for-gsoc.html</id><summary type="html">&lt;p&gt;Hello&amp;nbsp;all,&lt;/p&gt;
&lt;p&gt;This is the first post in a series of posts, in which I will cover my Google Summer Of Code(GSoC)&amp;nbsp;experience. &lt;/p&gt;
&lt;p&gt;I remember that I had heard about GSoC back when I was in my first year of college education, but I never actually tried to participate in the event thinking that its just only for the elite programmers. But finally on my third year of college education, I finally thought &amp;#8220;I should atleast try&amp;#8221; and with that I started my preparations for GSoC&amp;#8216;16. I started preparing for the event from early&amp;nbsp;January. &lt;/p&gt;
&lt;p&gt;I started out with visiting all the previously selected organizations, and collected information specifically on&amp;nbsp;-&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What kind of proposals get selected, and which ones&amp;nbsp;don&amp;#8217;t&lt;/li&gt;
&lt;li&gt;What are different steps involved in participating in&amp;nbsp;GSoC&lt;/li&gt;
&lt;li&gt;What are the various pre requisites for various organizations and&amp;nbsp;projects&lt;/li&gt;
&lt;li&gt;Read all possible links related to summer of code, and about the&amp;nbsp;program&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After my initial analysis of various organizations, I started picking out various organizations with which I would like to work with over the summer. I already had set my mind that I will only work on projects involving python as I had recently learned that langauge and was excited to further strenthen my skills in it. Already knowing what tech stack I wanted to work with really helped me out in selecting the&amp;nbsp;organization.&lt;/p&gt;
&lt;p&gt;Some of the organizations that I had selected were&amp;nbsp;-  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class="caps"&gt;C3G&lt;/span&gt;&lt;/strong&gt; : Canadian Centre for Computational Genomics, org working on computational&amp;nbsp;genomics  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BioJS&lt;/strong&gt; : Another awesome org working on computational biology and&amp;nbsp;visualization  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ScraPy&lt;/strong&gt; :  Related to web&amp;nbsp;scraping  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class="caps"&gt;CC&lt;/span&gt; Extractor&lt;/strong&gt; :  I was interested in their infrastructure related project&amp;nbsp;idea.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;myhdl&lt;/strong&gt; : Org with projects on Hardware Descripting Languages in&amp;nbsp;python  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ascend&lt;/strong&gt; : Org focussing on computational&amp;nbsp;chemistry  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After short listing orgs, I started sending out emails to the prospective mentors &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; mailing lists of the projects that I was interested in. I got a lot of psotive feedback from many mentors. And then, I started focussing on the projects that really interested me. Out of all of them &lt;strong&gt;SegAnnDB project idea, from &lt;span class="caps"&gt;C3G&lt;/span&gt;&lt;/strong&gt; stood out to&amp;nbsp;me.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;The Org&lt;/strong&gt;&amp;nbsp;-&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;C3G&lt;/span&gt; is a org completely focussed on computational biology. Mind you, it was a field that I literally knew nothing about. But, I really wanted to understand this, and do this project. It was a nice challenge as well. So after 5 years I started learning about biology and genomics&amp;nbsp;again.  &lt;/p&gt;
&lt;p&gt;I studied computational genomics day and night for a few days, so that I can better understand all the intricacies involved with the project. This was a very crucial step and it really helped in understanding my project inside&amp;nbsp;out.  &lt;/p&gt;
&lt;p&gt;Needless to say, a lot of credit goes to my project mentor Toby Hocking as well. He is a wonderful guy and he pointed me to all the correct resources to read&amp;nbsp;through.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;The Proposal&lt;/strong&gt;&amp;nbsp;-&lt;/h3&gt;
&lt;p&gt;After some good and positive discussions about the project with my mentor, I started working on my project proposal. As for &lt;span class="caps"&gt;C3G&lt;/span&gt; we already had a proposal template. And after some modifications in my draft, I finally submitted it to google and then the month long wait started. It was the longest wait ever, I remember I used to check GSoC dashboard alomst on an hourly basis&amp;nbsp;everyday.&lt;/p&gt;
&lt;p&gt;That&amp;#8217;s it for now. In my next post I will cover more details about my project and what I plan to acheive in this coming&amp;nbsp;summer. &lt;/p&gt;</summary><category term="Gsoc"></category><category term="computational genomics"></category><category term="google summer of code"></category></entry></feed>